# Getting Started with Harness Feature Management and Experimentation (FME) and Terraform

This comprehensive guide will walk you through setting up and deploying feature flags using our Terraform module across different scenarios.

## üìã Prerequisites

Before you begin, ensure you have:

- **Terraform** >= 1.5 
- **Split.io account** with API access

## üöÄ Quick Start

### 1. Environment Setup

```bash
# Clone the repository
git clone <repository-url> harness-fme-terraform
cd harness-fme-terraform

# Set your Split.io API key
export TF_VAR_split_api_key="your-split-io-api-key"

# Initialize Terraform
terraform init
```

### 2. Choose Your Scenario

| Scenario | Best For | Complexity | Time to Deploy |
|----------|----------|------------|----------------|
| [Simple Toggle](#simple-toggle-scenario) | Learning basics | Beginner | 5 minutes |
| [Multi-Environment](#multi-environment-scenario) | Production usage | Intermediate | 15 minutes |
| [Advanced Targeting](#advanced-targeting-scenario) | Complex rules | Advanced | 30 minutes |
| [A/B Testing](#ab-testing-scenario) | Experimentation | Intermediate | 20 minutes |
| [Killswitch](#killswitch-scenario) | Emergency controls | Intermediate | 10 minutes |

## üìò Scenario 1: Simple Toggle

Perfect for understanding the basics of feature flags.

### Use Case
A simple on/off feature toggle for a new UI component.

### Configuration

```hcl
# main.tf
module "simple_feature_flags" {
  source = "./modules/split-feature-flags"

  split_api_key       = var.split_api_key
  workspace_name      = "Default"
  environment_name    = "development"
  is_production       = false
  traffic_type_name   = "user"

  feature_flags = [
    {
      name              = "new-ui-component"
      description       = "Toggle for new dashboard UI component"
      default_treatment = "off"
      environments      = ["dev"]
      lifecycle_stage   = "development"
      category          = "feature"
      
      treatments = [
        {
          name           = "off"
          configurations = "{\"enabled\": false}"
          description    = "Original UI component"
        },
        {
          name           = "on"
          configurations = "{\"enabled\": true, \"version\": \"v2\"}"
          description    = "New UI component enabled"
        }
      ]
      
      rules = []  # No targeting rules - simple on/off
    }
  ]
}
```

### Deployment Commands

```bash
# Plan the deployment
terraform plan -var="split_api_key=$TF_VAR_split_api_key"

# Apply the configuration
terraform apply -var="split_api_key=$TF_VAR_split_api_key"
```

### Expected Outcome
- Creates a simple feature flag in development environment
- Default treatment is "off" (safe default)
- Can be toggled via Split.io dashboard

---

## üåç Scenario 2: Multi-Environment

Ideal for production workflows with progressive deployment.

### Use Case
Deploy a payment processing feature across development, staging, and production environments with different configurations.

### Configuration

```hcl
# main.tf
module "multi_env_feature_flags" {
  source = "./modules/split-feature-flags"

  split_api_key       = var.split_api_key
  workspace_name      = var.workspace_name
  environment_name    = var.environment_name
  is_production       = var.is_production
  traffic_type_name   = "user"

  feature_flags = [
    {
      name              = "payment-processor-v2"
      description       = "New payment processing system"
      default_treatment = "legacy"
      environments      = ["dev", "staging", "prod"]
      lifecycle_stage   = "production"
      category          = "feature"
      
      # Base configuration (conservative defaults)
      treatments = [
        {
          name           = "legacy"
          configurations = "{\"processor\": \"v1\", \"timeout\": 30}"
          description    = "Current payment processor"
        },
        {
          name           = "enhanced"
          configurations = "{\"processor\": \"v2\", \"timeout\": 25}"
          description    = "Enhanced payment processor"
        }
      ]
      
      rules = []
      
      # Environment-specific optimizations
      environment_configs = {
        # Development: Extended timeouts and debug features
        dev = {
          description = "Payment processor v2 with debug features"
          treatments = [
            {
              name           = "legacy"
              configurations = "{\"processor\": \"v1\", \"timeout\": 60, \"debug\": true}"
              description    = "Legacy with debug logging"
            },
            {
              name           = "enhanced"
              configurations = "{\"processor\": \"v2\", \"timeout\": 60, \"debug\": true, \"mock_mode\": true}"
              description    = "Enhanced with development features"
            }
          ]
          rules = [
            {
              treatment = "enhanced"
              size      = 50  # 50% of dev traffic gets new processor
            }
          ]
        }
        
        # Staging: Production-like with monitoring
        staging = {
          description = "Payment processor v2 with comprehensive monitoring"
          treatments = [
            {
              name           = "legacy"
              configurations = "{\"processor\": \"v1\", \"timeout\": 30, \"monitoring\": true}"
              description    = "Legacy with monitoring"
            },
            {
              name           = "enhanced"
              configurations = "{\"processor\": \"v2\", \"timeout\": 25, \"monitoring\": true, \"analytics\": true}"
              description    = "Enhanced with full observability"
            }
          ]
          rules = [
            {
              treatment = "enhanced"
              size      = 25  # 25% of staging traffic
              condition = {
                matcher = {
                  type      = "IN_SEGMENT"
                  attribute = "customer_tier"
                  strings   = ["beta", "internal"]
                }
              }
            }
          ]
        }
        
        # Production: Optimized and secure
        prod = {
          description = "Production payment processor v2 with security controls"
          treatments = [
            {
              name           = "legacy"
              configurations = "{\"processor\": \"v1\", \"timeout\": 30, \"security_enhanced\": true}"
              description    = "Production legacy processor"
            },
            {
              name           = "enhanced"
              configurations = "{\"processor\": \"v2\", \"timeout\": 20, \"security_enhanced\": true, \"performance_optimized\": true}"
              description    = "Production enhanced processor"
            }
          ]
          rules = [
            {
              treatment = "enhanced"
              size      = 5  # Conservative 5% rollout in production
              condition = {
                matcher = {
                  type      = "IN_SEGMENT"
                  attribute = "customer_tier"
                  strings   = ["premium"]
                }
              }
            }
          ]
        }
      }
    }
  ]
}
```

### Environment Variables Files

```hcl
# environments/dev.tfvars
environment_name = "dev"
is_production    = false

# environments/staging.tfvars
environment_name = "staging"
is_production    = false

# environments/prod.tfvars
environment_name = "prod"
is_production    = true
```

### Deployment Commands

```bash
# Deploy to development
terraform apply \
  -var-file="environments/dev.tfvars" \
  -var="split_api_key=$TF_VAR_split_api_key"

# Deploy to staging
terraform apply \
  -var-file="environments/staging.tfvars" \
  -var="split_api_key=$TF_VAR_split_api_key"

# Deploy to production
terraform apply \
  -var-file="environments/prod.tfvars" \
  -var="split_api_key=$TF_VAR_split_api_key"
```

### Expected Outcome
- Development: 50% traffic gets enhanced processor with debug features
- Staging: 25% of beta users get enhanced processor with monitoring
- Production: 5% of premium users get enhanced processor with security

---

## üéØ Scenario 3: Advanced Targeting

For complex user segmentation and targeting rules.

### Use Case
Premium features with different access levels based on user segments and attributes.

### Configuration

```hcl
# main.tf
module "advanced_targeting" {
  source = "./modules/split-feature-flags"

  split_api_key       = var.split_api_key
  workspace_name      = "Default"
  environment_name    = "production"
  is_production      = true
  traffic_type_name  = "user"

  feature_flags = [
    {
      name              = "premium-dashboard"
      description       = "Premium dashboard with advanced analytics"
      default_treatment = "basic"
      environments      = ["dev", "staging", "prod"]
      lifecycle_stage   = "production"
      category          = "feature"
      
      treatments = [
        {
          name           = "basic"
          configurations = "{\"dashboard_type\": \"basic\", \"features\": [\"overview\", \"reports\"]}"
          description    = "Basic dashboard features"
        },
        {
          name           = "premium"
          configurations = "{\"dashboard_type\": \"premium\", \"features\": [\"overview\", \"reports\", \"analytics\", \"export\"]}"
          description    = "Premium dashboard with analytics"
        },
        {
          name           = "enterprise"
          configurations = "{\"dashboard_type\": \"enterprise\", \"features\": [\"overview\", \"reports\", \"analytics\", \"export\", \"custom_widgets\", \"api_access\"]}"
          description    = "Enterprise dashboard with all features"
        }
      ]
      
      rules = [
        {
          treatment = "enterprise"
          size      = 100
          condition = {
            matcher = {
              type      = "IN_SEGMENT"
              attribute = "subscription_tier"
              strings   = ["enterprise"]
            }
          }
        },
        {
          treatment = "premium"
          size      = 100
          condition = {
            matcher = {
              type      = "IN_SEGMENT"
              attribute = "subscription_tier"
              strings   = ["premium", "business"]
            }
          }
        },
        {
          treatment = "premium"
          size      = 10  # 10% of basic users get premium as trial
          condition = {
            matcher = {
              type      = "IN_SEGMENT"
              attribute = "user_segment"
              strings   = ["trial_eligible"]
            }
          }
        }
      ]
    },
    {
      name              = "geographic-features"
      description       = "Location-based feature access"
      default_treatment = "standard"
      environments      = ["prod"]
      lifecycle_stage   = "production"
      category          = "feature"
      
      treatments = [
        {
          name           = "standard"
          configurations = "{\"features\": [\"basic_maps\", \"location_search\"]}"
          description    = "Standard geographic features"
        },
        {
          name           = "enhanced_eu"
          configurations = "{\"features\": [\"basic_maps\", \"location_search\", \"gdpr_tools\", \"eu_analytics\"]}"
          description    = "Enhanced features for EU users"
        },
        {
          name           = "enhanced_us"
          configurations = "{\"features\": [\"basic_maps\", \"location_search\", \"detailed_analytics\", \"marketing_tools\"]}"
          description    = "Enhanced features for US users"
        }
      ]
      
      rules = [
        {
          treatment = "enhanced_eu"
          size      = 100
          condition = {
            matcher = {
              type      = "IN_SEGMENT"
              attribute = "user_region"
              strings   = ["EU", "EEA"]
            }
          }
        },
        {
          treatment = "enhanced_us"
          size      = 100
          condition = {
            matcher = {
              type      = "IN_SEGMENT"
              attribute = "user_region"
              strings   = ["US", "CA"]
            }
          }
        }
      ]
    }
  ]
}
```

### Expected Outcome
- Enterprise users get full dashboard access
- Premium/Business users get premium dashboard
- 10% of trial-eligible basic users get premium features as trial
- Geographic features adapt based on user region (EU vs US)

---

## üß™ Scenario 4: A/B Testing

For experimentation and data-driven decision making.

### Use Case
Test different checkout flow variations to optimize conversion rates.

### Configuration

```hcl
# main.tf
module "ab_testing" {
  source = "./modules/split-feature-flags"

  split_api_key       = var.split_api_key
  workspace_name      = "Default"
  environment_name    = var.environment_name
  is_production       = var.is_production
  traffic_type_name   = "user"

  feature_flags = [
    {
      name              = "checkout-optimization"
      description       = "A/B test for checkout flow optimization"
      default_treatment = "control"
      environments      = ["staging", "prod"]
      lifecycle_stage   = "testing"
      category          = "experiment"
      
      treatments = [
        {
          name           = "control"
          configurations = "{\"flow_type\": \"original\", \"steps\": 4, \"progress_bar\": false}"
          description    = "Original 4-step checkout flow"
        },
        {
          name           = "streamlined"
          configurations = "{\"flow_type\": \"streamlined\", \"steps\": 3, \"progress_bar\": true}"
          description    = "Streamlined 3-step flow with progress bar"
        },
        {
          name           = "enhanced"
          configurations = "{\"flow_type\": \"enhanced\", \"steps\": 4, \"progress_bar\": true, \"auto_save\": true}"
          description    = "Enhanced flow with auto-save and progress"
        }
      ]
      
      # Environment-specific experiment configuration
      environment_configs = {
        staging = {
          description = "Checkout optimization testing in staging"
          rules = [
            {
              treatment = "streamlined"
              size      = 50  # 50% get streamlined flow
            },
            {
              treatment = "enhanced"
              size      = 50  # 50% get enhanced flow
            }
          ]
        }
        
        prod = {
          description = "Checkout optimization A/B test in production"
          rules = [
            {
              treatment = "streamlined"
              size      = 20  # 20% get streamlined flow
              condition = {
                matcher = {
                  type      = "IN_SEGMENT"
                  attribute = "user_segment"
                  strings   = ["experiment_group"]
                }
              }
            },
            {
              treatment = "enhanced"
              size      = 20  # 20% get enhanced flow
              condition = {
                matcher = {
                  type      = "IN_SEGMENT"
                  attribute = "user_segment"
                  strings   = ["experiment_group"]
                }
              }
            }
          ]
        }
      }
    },
    {
      name              = "pricing-display-test"
      description       = "Test different pricing display formats"
      default_treatment = "standard"
      environments      = ["prod"]
      lifecycle_stage   = "testing"
      category          = "experiment"
      
      treatments = [
        {
          name           = "standard"
          configurations = "{\"format\": \"standard\", \"currency_symbol\": \"$\", \"decimal_places\": 2}"
          description    = "Standard pricing format"
        },
        {
          name           = "rounded"
          configurations = "{\"format\": \"rounded\", \"currency_symbol\": \"$\", \"decimal_places\": 0}"
          description    = "Rounded pricing (no cents)"
        },
        {
          name           = "emphasis"
          configurations = "{\"format\": \"emphasis\", \"currency_symbol\": \"$\", \"decimal_places\": 2, \"highlight\": true}"
          description    = "Emphasized pricing with highlights"
        }
      ]
      
      rules = [
        {
          treatment = "rounded"
          size      = 33  # 33% get rounded pricing
        },
        {
          treatment = "emphasis"
          size      = 33  # 33% get emphasized pricing
        }
        # Remaining 34% get standard (default)
      ]
    }
  ]
}
```

### Expected Outcome
- Staging: 50/50 split between streamlined and enhanced checkout flows
- Production: 20% each for experimental flows, 60% control group
- Pricing test: Equal split between three pricing display formats

---

## ‚ö° Scenario 5: Killswitch

For emergency controls.

### Use Case
Emergency controls for critical system components that need instant rollback capability.

### Configuration

```hcl
# main.tf
module "killswitch_controls" {
  source = "./modules/split-feature-flags"

  split_api_key       = var.split_api_key
  workspace_name      = "Default"
  environment_name    = "production"
  is_production       = true
  traffic_type_name   = "user"

  feature_flags = [
    {
      name              = "api-rate-limiter"
      description       = "Emergency API rate limiting controls"
      default_treatment = "normal"
      environments      = ["dev", "staging", "prod"]
      lifecycle_stage   = "production"
      category          = "killswitch"
      
      treatments = [
        {
          name           = "normal"
          configurations = "{\"rate_limit\": 1000, \"circuit_breaker\": false, \"timeout\": 30}"
          description    = "Normal operation - standard rate limits"
        },
        {
          name           = "restricted"
          configurations = "{\"rate_limit\": 500, \"circuit_breaker\": false, \"timeout\": 15}"
          description    = "Restricted mode - reduced rate limits"
        },
        {
          name           = "emergency"
          configurations = "{\"rate_limit\": 100, \"circuit_breaker\": true, \"timeout\": 5}"
          description    = "Emergency mode - severe restrictions"
        },
        {
          name           = "maintenance"
          configurations = "{\"rate_limit\": 0, \"circuit_breaker\": true, \"timeout\": 1}"
          description    = "Maintenance mode - API disabled"
        }
      ]
      
      rules = []  # No automatic rules - manual control only
    },
    {
      name              = "payment-system-circuit-breaker"
      description       = "Payment system circuit breaker for outages"
      default_treatment = "active"
      environments      = ["prod"]
      lifecycle_stage   = "production"
      category          = "killswitch"
      
      treatments = [
        {
          name           = "active"
          configurations = "{\"payment_enabled\": true, \"fallback_mode\": false}"
          description    = "Payment system active"
        },
        {
          name           = "fallback"
          configurations = "{\"payment_enabled\": false, \"fallback_mode\": true, \"message\": \"Payment temporarily unavailable\"}"
          description    = "Fallback mode - payments disabled with message"
        },
        {
          name           = "maintenance"
          configurations = "{\"payment_enabled\": false, \"fallback_mode\": true, \"message\": \"System under maintenance\"}"
          description    = "Maintenance mode with custom message"
        }
      ]
      
      rules = []  # Manual control only for safety
    },
    {
      name              = "feature-rollback-switch"
      description       = "Master switch to rollback new features"
      default_treatment = "new_features"
      environments      = ["prod"]
      lifecycle_stage   = "production"
      category          = "killswitch"
      
      treatments = [
        {
          name           = "new_features"
          configurations = "{\"enable_new_ui\": true, \"enable_new_api\": true, \"enable_beta_features\": true}"
          description    = "All new features enabled"
        },
        {
          name           = "stable_only"
          configurations = "{\"enable_new_ui\": false, \"enable_new_api\": false, \"enable_beta_features\": false}"
          description    = "Only stable features - all new features disabled"
        }
      ]
      
      rules = []  # Emergency manual control
    }
  ]
}
```

### Emergency Response Procedures

```bash
# Emergency: Activate API rate limiting
# Update via Split.io dashboard or API:
# - Set "api-rate-limiter" to "restricted" for immediate relief
# - Set to "emergency" for severe issues
# - Set to "maintenance" for complete API shutdown

# Emergency: Payment system issues
# - Set "payment-system-circuit-breaker" to "fallback"
# - Monitor and switch back to "active" when resolved

# Emergency: New feature causing issues
# - Set "feature-rollback-switch" to "stable_only"
# - All new features immediately disabled
```

### Expected Outcome
- Instant control over critical system components
- Manual-only activation for safety
- Clear emergency response procedures
- Minimal customer impact during incidents

---

## üõ†Ô∏è Advanced Configuration Patterns

### 1. Dynamic Configuration Values using JSON structures or JSON files

```hcl
{
  name              = "dynamic-config"
  description       = "Feature with dynamic configuration values"
  default_treatment = "default"
  environments      = ["prod"]
  
  treatments = [
    {
      name           = "default"
      configurations = jsonencode({
        api_timeout    = 30
        retry_count    = 3
        cache_ttl      = 300
        feature_limits = {
          max_requests = 1000
          max_file_size = "10MB"
        }
      })
      description = "Default configuration"
    },
    {
      name           = "performance"
      configurations = jsonencode({
        api_timeout    = 15
        retry_count    = 5
        cache_ttl      = 600
        feature_limits = {
          max_requests = 2000
          max_file_size = "20MB"
        }
      })
      description = "High-performance configuration"
    }
  ]
}
```

### 2. Conditional Environment Deployment

```hcl
locals {
  # Deploy experimental features only in dev and staging
  experimental_environments = ["dev", "staging"]
  
  # Deploy stable features across all environments
  stable_environments = ["dev", "staging", "prod"]
}

feature_flags = [
  {
    name         = "experimental-feature"
    environments = local.experimental_environments
    # ... rest of configuration
  },
  {
    name         = "stable-feature"
    environments = local.stable_environments
    # ... rest of configuration
  }
]
```

### 3. Gradual Rollout Pattern

```hcl
{
  name              = "gradual-rollout"
  description       = "Feature with gradual percentage rollout"
  default_treatment = "off"
  
  # Start with small percentage and gradually increase
  environment_configs = {
    prod = {
      rules = [
        {
          treatment = "on"
          size      = 5  # Start with 5%, increase gradually
          # Can be updated via Split.io dashboard as confidence grows
        }
      ]
    }
  }
}
```

## üîß Terraform Module Usage Patterns

### Module Configuration Patterns

#### Basic Module Usage
```hcl
module "feature_flags" {
  source = "./modules/split-feature-flags"

  split_api_key     = var.split_api_key
  workspace_name    = "MyWorkspace"
  environment_name  = "development"
  is_production     = false
  traffic_type_name = "user"

  feature_flags = [
    # Your feature flag configurations here
  ]
}
```

#### Multiple Environment Deployments
```hcl
# Deploy same configuration across environments
# Use different .tfvars files for each environment

# environments/dev.tfvars
environment_name = "dev"
is_production    = false

# environments/prod.tfvars  
environment_name = "prod"
is_production    = true
```

## üêõ Troubleshooting Guide

### Common Issues and Solutions

#### 1. API Authentication Errors
```
Error: Unable to authenticate with Split.io API
```
**Solutions:**
- Verify API key is correct and active
- Check API key permissions in Split.io dashboard
- Ensure API key is for the correct workspace

#### 2. Environment Filtering Not Working
```
Feature flag not appearing in expected environment
```
**Solutions:**
- Check `environments` array includes target environment
- Verify `environment_name` variable matches exactly
- Review environment-specific configurations

#### 3. Feature Flag Validation Errors
```
Error: Treatment 'xyz' not found in treatments list
```
**Solutions:**
- Ensure all referenced treatments are defined
- Check treatment names for typos
- Verify default_treatment exists in treatments array

#### 4. Terraform State Issues
```
Error: Resource already exists
```
**Solutions:**
- Import existing resources: `terraform import split_split.example workspace_id/split_id`
- Use `terraform refresh` to sync state
- Check for resource naming conflicts

### Debug Commands

```bash
# Validate Terraform configuration
terraform validate

# Check what will be created/changed
terraform plan -var="split_api_key=$TF_VAR_split_api_key"

# Show current state
terraform show

# List all resources
terraform state list

# Show specific resource details
terraform state show split_split.feature_name

# Refresh state from Split.io
terraform refresh -var="split_api_key=$TF_VAR_split_api_key"
```

## ‚úÖ Best Practices

### 1. Naming Conventions
- Use kebab-case for feature flag names: `payment-processor-v2`
- Include version numbers for feature iterations: `checkout-flow-v3`
- Use descriptive names that explain the feature's purpose

### 2. Environment Strategy
- Start with development environment
- Use staging for production-like testing
- Deploy to production with conservative rollout percentages

### 3. Safety Measures
- Always use safe defaults (typically "off" or existing behavior)
- Implement gradual rollouts for new features
- Create killswitches for critical features
- Test thoroughly in staging before production

### 4. Configuration Management
- Use separate variable files for each environment
- Store sensitive data (API keys) in environment variables
- Version control all configuration files
- Document feature flag purposes and expected behaviors

### 5. Monitoring and Observability
- Monitor feature flag evaluation metrics
- Set up alerts for unusual traffic patterns
- Track business metrics impacted by feature flags
- Regularly review and clean up unused flags

## üìö Next Steps

After completing this guide:

1. **Read Advanced Documentation**
   - [Technical Architecture](../technical/1.architecture.md)
   - [Feature Flag Management Strategy](../technical/2.feature-flag-management.md)

2. **Explore Use Cases**
   - Banking Platform Implementation
   - E-commerce Platform (coming soon)
   - Mobile Application Features (coming soon)

3. **Production Preparation**
   - Set up Terraform remote state management
   - Implement proper API key management
   - Review security and validation patterns
   - Plan feature flag governance and lifecycle

4. **Advanced Module Usage**
   - Implement environment-specific configurations
   - Use complex targeting rules and segmentation
   - Set up feature flag lifecycle management
   - Review [Examples](2.examples.md) for additional patterns