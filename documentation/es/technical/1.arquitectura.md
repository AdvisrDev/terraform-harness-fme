# Arquitectura Técnica - Módulos de Terraform para Split.io

Este documento proporciona una visión técnica completa de la arquitectura de módulos de Terraform para gestionar feature flags de Split.io e infraestructura de administración en múltiples entornos.

## 🏗️ Resumen de Arquitectura del Módulo

```
┌─────────────────────────────────────────────────────────────────────────┐
│                   Módulos de Terraform para Split.io                   │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ┌──────────────────────────┐    ┌──────────────────────────────────┐   │
│  │   split-feature-flags    │    │    split-administration          │   │
│  │                          │    │                                  │   │
│  │  Variables de Entrada:   │    │  Variables de Entrada:           │   │
│  │  • workspace_name        │    │  • environment_name              │   │
│  │  • environment_name      │    │  • workspace                     │   │
│  │  • traffic_type_name     │    │  • environments                  │   │
│  │  • feature_flags[]       │    │  • traffic_types                 │   │
│                             │    │  • segments                      │   │
│  │  Características:        │    │  • api_keys[]                    │   │
│  │  • Filtrado de entornos  │    │  • environment_segment_keys[]    │   │
│  │  • Fusión de config      │    │                                  │   │
│  │  • Validación            │    │  Características:                │   │
│  │                          │    │  • Filtrado de entornos          │   │
│  │  Salida:                 │    │  • Fusión de config para keys   │   │
│  │  • Feature flag splits   │    │                                  │   │
│  │  • Definiciones split    │    │  Salida:                         │   │
│  └──────────────────────────┘    │  • Recursos infraestructura      │   │
│                                  │  • API keys, segment keys        │   │
│                                  └──────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
```

## 🧩 Componentes Centrales

### 1. Módulo split-feature-flags

Gestiona definiciones y splits de feature flags con configuraciones específicas por entorno.

#### Características Clave
- **Filtrado de Entornos**: Solo despliega flags en entornos especificados
- **Fusión de Configuraciones**: Fusiona configuraciones base con overrides de entorno
- **Configuración Flexible**: Mismos treatments en todos los entornos O diferentes por entorno

#### Estructura de Variables
```hcl
variable "feature_flags" {
  type = list(object({
    name              = string
    description       = string
    default_treatment = string
    environments      = list(string)
    lifecycle_stage   = string
    category          = string
    
    treatments = list(object({
      name           = string
      configurations = string
      description    = string
    }))
    
    rules = list(object({
      treatment = string
      size      = number
      condition = object({
        matcher = object({
          type      = string
          attribute = string
          strings   = list(string)
        })
      })
    }))
    
    # Overrides específicos por entorno
    environment_configs = map(object({
      default_treatment = string
      description       = string
      treatments        = list(object({...}))
      rules            = list(object({...}))
    }))
  }))
}
```

### 2. Módulo split-administration

Gestiona workspace, entornos, tipos de tráfico, segmentos, API keys y segment keys.

#### Características Clave
- **Filtrado de Entornos**: Filtra API keys y segment keys por entorno
- **Fusión de Configuraciones**: Fusiona configuraciones base con overrides específicos por entorno
- **Gestión de Infraestructura**: Crea y gestiona infraestructura de Split.io

#### Estructura de Variables
```hcl
variable "api_keys" {
  type = list(object({
    name         = string
    type         = string
    roles        = list(string)
    environments = list(string)
    environment_configs = map(object({
      name  = string
      type  = string
      roles = list(string)
    }))
  }))
}

variable "environment_segment_keys" {
  type = list(object({
    name         = string
    segment_name = string
    keys         = list(string)
    environments = list(string)
    environment_configs = map(object({
      keys = list(string)
    }))
  }))
}
```

## 🔄 Patrón de Filtrado de Entornos

Ambos módulos usan el mismo patrón de filtrado de entornos:

```hcl
# Filtrar elementos para el entorno actual
environment_items = [
  for item in var.items : item
  if length(item.environments) == 0 || contains(item.environments, var.environment_name)
]

# Fusionar configuración base con overrides de entorno
merged_items = [
  for item in local.environment_items : {
    name = try(item.environment_configs[var.environment_name].name, item.name)
    # ... otras propiedades con fallback try()
  }
]
```

## 📊 Motor de Fusión de Configuraciones

### Flujo de Lógica de Fusión

```
┌─────────────────────────────────────────────────────────────────────────┐
│                  Motor de Fusión de Configuraciones                     │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Entrada: items[] + entorno_actual                                      │
│                                     │                                   │
│                                     ▼                                   │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │                Para Cada Elemento                               │    │
│  │                                                                 │    │
│  │  1. Comenzar con configuración base                             │    │
│  │     ┌─────────────────────────────────────────────────────┐     │    │
│  │     │ Config Base:                                        │     │    │
│  │     │ • name: "api-key"                                   │     │    │
│  │     │ • type: "server_side"                               │     │    │
│  │     │ • roles: ["API_FEATURE_FLAG_VIEWER"]                │     │    │
│  │     └─────────────────────────────────────────────────────┘     │    │
│  │                                │                                │    │
│  │                                ▼                                │    │
│  │  2. Verificar overrides específicos por entorno                 │    │
│  │     ┌─────────────────────────────────────────────────────┐     │    │
│  │     │ environment_configs["prod"]: {                      │     │    │
│  │     │   name: "prd-api-key"                               │     │    │
│  │     │   roles: ["API_FEATURE_FLAG_VIEWER", "API_AUDIT"]   │     │    │
│  │     │ }                                                   │     │    │
│  │     └─────────────────────────────────────────────────────┘     │    │
│  │                                │                                │    │
│  │                                ▼                                │    │
│  │  3. Aplicar lógica de fusión con función try()                  │    │
│  │     ┌─────────────────────────────────────────────────────┐     │    │
│  │     │ merged_config = {                                   │     │    │
│  │     │   name: try(override.name, base.name)               │     │    │
│  │     │   type: try(override.type, base.type)               │     │    │
│  │     │   roles: try(override.roles, base.roles)            │     │    │
│  │     │ }                                                   │     │    │
│  │     └─────────────────────────────────────────────────────┘     │    │
│  │                                │                                │    │
│  │                                ▼                                │    │
│  │  4. Resultado: Configuración final fusionada                    │    │
│  │     ┌─────────────────────────────────────────────────────┐     │    │
│  │     │ Config Final:                                       │     │    │
│  │     │ • name: "prd-api-key"                               │     │    │
│  │     │ • type: "server_side"                               │     │    │
│  │     │ • roles: ["API_FEATURE_FLAG_VIEWER", "API_AUDIT"]   │     │    │
│  │     └─────────────────────────────────────────────────────┘     │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│                                     │                                   │
│                                     ▼                                   │
│  Salida: merged_items[]                                                 │
└─────────────────────────────────────────────────────────────────────────┘
```

## 🔧 Patrones de Extensión

### 1. Agregar Nuevas Propiedades Específicas por Entorno

```hcl
# En variables.tf
environment_configs = map(object({
  # Propiedades existentes
  name  = optional(string)
  type  = optional(string)
  roles = optional(list(string))
  
  # Nueva propiedad específica por entorno
  timeout_seconds = optional(number)
}))

# En main.tf locals
merged_items = [
  for item in local.environment_items : {
    # Fusiones existentes
    name = try(item.environment_configs[var.environment_name].name, item.name)
    
    # Nueva fusión de propiedad
    timeout_seconds = try(
      item.environment_configs[var.environment_name].timeout_seconds, 
      item.timeout_seconds
    )
  }
]
```

### 2. Agregar Validación Personalizada

```hcl
variable "api_keys" {
  # ... definición de tipo
  
  validation {
    condition = alltrue([
      for key in var.api_keys :
      key.type == "admin" ? contains(key.roles, "API_ALL_GRANTED") : true
    ])
    error_message = "API keys admin deben tener el rol API_ALL_GRANTED"
  }
}
```

### 3. Crear Recursos Específicos por Entorno

```hcl
# Filtrar y crear recursos solo para el entorno actual
resource "split_api_key" "this" {
  for_each = local.api_keys_map
  
  workspace_id    = local.workspace_id
  environment_ids = [local.environment_id]
  name            = each.value.name
  type            = each.value.type
  roles           = each.value.roles
}
```

## 📈 Patrones de Uso

### 1. Patrón de Configuración Común

```hcl
# common.tfvars
api_keys = [
  {
    name = "server"
    type = "server_side"
    roles = ["API_FEATURE_FLAG_VIEWER"]
    environments = ["dev", "staging", "prod"]
    environment_configs = {
      dev = { name = "dev-server" }
      staging = { name = "stg-server" }
      prod = { name = "prd-server" }
    }
  }
]
```

### 2. Patrón de Configuración Específica por Entorno

```hcl
# environments/development.tfvars
environment_name = "dev"

# Elementos solo para desarrollo
api_keys = [
  {
    name = "debug"
    type = "admin"
    roles = ["API_ALL_GRANTED"]
    environments = ["dev"]
  }
]
```

### 3. Patrón de Consumo de Módulos

```hcl
# main.tf del caso de uso
module "administration" {
  source = "../../modules/split-administration"
  
  environment_name         = var.environment_name
  workspace                = var.workspace
  environments             = var.environments
  api_keys                 = local.all_api_keys
  environment_segment_keys = local.all_segment_keys
}

locals {
  # Fusionar configuraciones comunes y específicas por entorno
  all_api_keys = concat(
    var.common_api_keys != null ? var.common_api_keys : [],
    var.api_keys != null ? var.api_keys : []
  )
}
```

## 🛡️ Mejores Prácticas

### 1. Seguridad de Entornos
- Usar array `environments` para controlar el alcance del despliegue
- Validar nombres de entorno contra valores permitidos
- Usar overrides específicos por entorno para configuraciones de seguridad

### 2. Gestión de Configuración
- Definir configuraciones comunes en `common.tfvars`
- Usar archivos específicos por entorno solo para elementos únicos del entorno
- Aprovechar environment_configs para overrides específicos por entorno

### 3. Estrategia de Validación
- Implementar reglas de validación comprehensivas
- Usar validaciones de terraform para feedback inmediato
- Validar referencias cruzadas entre configuraciones

Esta arquitectura proporciona una base sólida para gestionar infraestructura de Split.io y feature flags a escala mientras mantiene seguridad, rendimiento y mantenibilidad.